<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>결정장애 돌림판</title>
    
    <!-- PWA 메타 태그 -->
    <meta name="description" content="고민 그만! 돌림판이 결정해드릴게요 🎯 모바일 최적화된 PWA 앱">
    <meta name="keywords" content="돌림판, 결정장애, 선택, 랜덤, 결정, 룰렛, PWA, 모바일">
    <meta name="author" content="결정장애 돌림판">
    <meta name="theme-color" content="#4CAF50">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="돌림판">
    <meta name="mobile-web-app-capable" content="yes">
    
    <!-- Open Graph / 카카오톡 공유 최적화 -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="결정장애 돌림판 🎯">
    <meta property="og:description" content="결정하기 힘들 땐? 돌림판으로 결정해 보세요! 모바일 최적화된 PWA 앱">
    <meta property="og:image" content="https://raw.githubusercontent.com/5banjang/roulette/main/og_image.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:image:type" content="image/png">
    <meta property="og:url" content="https://5banjang.github.io/roulette/">
    <meta property="og:site_name" content="결정장애 돌림판">
    <meta property="og:locale" content="ko_KR">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="결정장애 돌림판 🎯">
    <meta name="twitter:description" content="결정하기 힘들 땐? 돌림판으로 결정해 보세요! 모바일 최적화된 PWA 앱">
    <meta name="twitter:image" content="https://raw.githubusercontent.com/5banjang/roulette/main/og_image.png">
    <meta name="twitter:image:alt" content="결정장애 돌림판 앱 스크린샷">
    
    <!-- PWA 매니페스트 -->
    <link rel="manifest" href="manifest.json">
    
    <!-- 파비콘 및 아이콘 -->
    <link rel="icon" type="image/png" href="icon-512x512.png">
    <link rel="apple-touch-icon" href="icon-512x512.png">
    <link rel="apple-touch-icon" sizes="180x180" href="icon-512x512.png">
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
/* 결정장애 돌림판 - 전문가급 모바일 PWA 스타일 */

/* ===================================== */
/* 💻 전체 레이아웃 & 반응형 기본 설정 */
/* ===================================== */

/* 브라우저 기본 여백 제거 */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

/* 가로 스크롤 방지를 위한 추가 설정 */
*, *::before, *::after {
    max-width: 100%;
    word-wrap: break-word;
}

/* 컨테이너 레이아웃 최적화 */
.min-h-screen {
    width: 100%;
    max-width: 100vw;
    overflow-x: hidden;
}

/* Flex 컨테이너 최적화 */
.flex {
    min-width: 0; /* flex item 축소 허용 */
}

.flex-grow, .flex-1 {
    min-width: 0; /* flex-grow 아이템이 너무 커지지 않도록 */
}

html, body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background-color: #f3f4f6;
    overflow-x: hidden; /* 가로 스크롤 원천 차단 */
    width: 100%;
    max-width: 100%;
}

/* 모바일 전용 스타일 */
@media (max-width: 767px) {
    html, body {
        width: 100vw;
        height: 100vh;
        position: fixed;
        -webkit-overflow-scrolling: touch;
        overscroll-behavior: none;
        overflow-x: hidden;
    }
    
    body > div {
        width: 100vw;
        height: 100vh;
        overflow-y: auto;
        overflow-x: hidden;
    }
    
    /* 모바일에서 flex 컨테이너 최적화 */
    .flex.flex-wrap {
        align-items: stretch;
    }
    
    /* 모바일에서 입력창 최적화 */
    .flex-grow {
        min-width: 200px; /* 최소 너비 보장 */
        flex-basis: 60%; /* 기본 너비 설정 */
    }
    
    /* 모바일에서 버튼 최적화 */
    .flex-1 {
        min-width: 90px; /* 버튼 최소 너비 */
        flex-basis: calc(33.333% - 8px); /* 3개 버튼이 한 줄에 들어갈 수 있도록 */
    }
    
    /* 작은 화면에서 버튼들이 세로로 배치되도록 */
    @media (max-width: 360px) {
        .flex-1 {
            flex-basis: calc(50% - 8px); /* 2개씩 배치 */
        }
    }
    
    @media (max-width: 280px) {
        .flex-1 {
            flex-basis: 100%; /* 1개씩 배치 */
        }
    }
}

/* 데스크톱 스타일 */
@media (min-width: 768px) {
    html, body {
        min-height: 100vh;
        width: 100%;
    }
    
    body > div {
        min-height: 100vh;
        width: 100%;
        display: flex;
        flex-direction: column;
    }
}

/* ===================================== */
/* 📱 모바일 퍼스트 터치 최적화 */
/* ===================================== */

/* 전체적인 터치 최적화 */
* {
    -webkit-tap-highlight-color: transparent;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}

/* 텍스트 입력 요소는 선택 가능하게 */
input, textarea {
    -webkit-user-select: text;
    -moz-user-select: text;
    -ms-user-select: text;
    user-select: text;
}

/* ===================================== */
/* 돌림판 캔버스 최적화 */
/* ===================================== */

#roulette-canvas {
    transform-origin: center center;
    transition: none;
    touch-action: none;
    width: min(70vw, 70vh, 320px);
    height: min(70vw, 70vh, 320px);
    max-width: 90vw;
    max-height: 50vh;
}

/* 세로 화면 최적화 */
@media (orientation: portrait) {
    #roulette-canvas {
        width: min(75vw, 40vh, 280px);
        height: min(75vw, 40vh, 280px);
    }
}

/* 가로 화면 최적화 */
@media (orientation: landscape) {
    #roulette-canvas {
        width: min(50vw, 60vh, 300px);
        height: min(50vw, 60vh, 300px);
    }
}

/* 초소형 화면 (320px 이하) */
@media (max-width: 320px) {
    #roulette-canvas {
        width: 70vw;
        height: 70vw;
        max-width: 240px;
        max-height: 240px;
    }
}

/* 데스크톱에서 추가 여백 */
@media (min-width: 768px) {
    .arrow-pointer {
        border-left: 16px solid transparent;
        border-right: 16px solid transparent;
        border-top: 50px solid #ef4444;
    }
    
    .arrow-pointer::after {
        top: -46px;
        left: -12px;
        border-left: 12px solid transparent;
        border-right: 12px solid transparent;
        border-top: 38px solid #dc2626;
    }
}

/* ===================================== */
/* 모바일 최적화 화살표 */
/* ===================================== */

.arrow-pointer {
    width: 0;
    height: 0;
    border-left: 14px solid transparent;
    border-right: 14px solid transparent;
    border-top: 45px solid #ef4444;
    position: relative;
    filter: drop-shadow(0 4px 8px rgba(239, 68, 68, 0.4));
    animation: arrow-pulse 2s ease-in-out infinite;
    transition: all 0.3s ease;
}

/* 화살표 내부 테두리 효과 */
.arrow-pointer::after {
    content: '';
    position: absolute;
    top: -42px;
    left: -10px;
    width: 0;
    height: 0;
    border-left: 10px solid transparent;
    border-right: 10px solid transparent;
    border-top: 35px solid #dc2626;
}

/* 돌리는 중 화살표 */
.arrow-pointer.spinning {
    animation: none;
    transform: scale(0.85);
    filter: drop-shadow(0 2px 6px rgba(239, 68, 68, 0.3));
}

/* 결과 확정시 화살표 강조 */
.arrow-pointer.result {
    animation: arrow-result 0.7s ease-in-out 3;
    transform: scale(1.3);
}

/* 화살표 애니메이션 */
@keyframes arrow-pulse {
    0%, 100% {
        transform: scale(1);
        filter: drop-shadow(0 4px 8px rgba(239, 68, 68, 0.4));
    }
    50% {
        transform: scale(1.1);
        filter: drop-shadow(0 6px 12px rgba(239, 68, 68, 0.6));
    }
}

@keyframes arrow-result {
    0%, 100% {
        transform: scale(1.3);
        filter: drop-shadow(0 6px 15px rgba(239, 68, 68, 0.8));
    }
    50% {
        transform: scale(1.5);
        filter: drop-shadow(0 8px 20px rgba(239, 68, 68, 1));
    }
}

/* ===================================== */
/* 터치 친화적인 버튼 스타일 */
/* ===================================== */

/* 모바일 버튼 스타일 */
@media (max-width: 767px) {
    button {
        min-height: max(48px, 8vh);
        touch-action: manipulation;
        -webkit-appearance: none;
        appearance: none;
        font-size: clamp(0.875rem, 4vw, 1.125rem);
        padding: clamp(0.75rem, 3vw, 1rem) clamp(1rem, 4vw, 1.5rem);
    }

    #spin-button, #reset-button, #share-button {
        font-size: clamp(1rem, 4.5vw, 1.25rem);
        min-height: max(60px, 10vh);
    }
}

/* 기본 버튼 스타일 */
button {
    touch-action: manipulation;
    -webkit-appearance: none;
    appearance: none;
    border: none;
    cursor: pointer;
    transition: all 0.2s ease;
    font-weight: 600;
}

/* 터치 피드백 효과 */
button:active {
    transform: scale(0.98);
    transition: transform 0.1s ease;
}

/* ===================================== */
/* 항목 태그 모바일 최적화 */
/* ===================================== */

.item-tag {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 0.75rem 1rem;
    border-radius: 12px;
    font-size: 1rem;
    font-weight: 600;
    display: inline-flex;
    align-items: center;
    gap: 0.75rem;
    transition: all 0.2s ease;
    min-height: 44px; /* 터치 최소 크기 */
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.item-tag:active {
    transform: scale(0.98);
}

/* 삭제 버튼 터치 최적화 */
.remove-btn {
    background: rgba(255, 255, 255, 0.25);
    border: none;
    border-radius: 50%;
    width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    color: white;
    font-size: 16px;
    font-weight: bold;
    transition: all 0.2s ease;
    min-width: 44px; /* 터치 영역 확대 */
    min-height: 44px;
    margin: -8px; /* 시각적 크기는 유지하되 터치 영역 확대 */
}

.remove-btn:active {
    background: rgba(255, 255, 255, 0.4);
    transform: scale(0.9);
}

/* ===================================== */
/* 즐겨찾기 아이템 모바일 최적화 */
/* ===================================== */

.load-favorite-btn,
.delete-favorite-btn {
    min-height: 44px;
    padding: 0.75rem 1rem;
    font-size: 0.9rem;
    font-weight: 600;
    border-radius: 8px;
    transition: all 0.2s ease;
}

.load-favorite-btn:active,
.delete-favorite-btn:active {
    transform: scale(0.95);
}

/* ===================================== */
/* 결과 표시 모바일 최적화 */
/* ===================================== */

.result-highlight {
    background: linear-gradient(135deg, #ffeaa7, #fab1a0);
    color: #2d3436;
    padding: 1.5rem 2rem;
    border-radius: 16px;
    font-weight: bold;
    font-size: 1.25rem;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    animation: mobile-bounce 0.6s ease-in-out;
    text-align: center;
    min-height: 4rem;
    display: flex;
    align-items: center;
    justify-content: center;
}

@keyframes mobile-bounce {
    0%, 20%, 60%, 100% {
        transform: translateY(0) scale(1);
    }
    40% {
        transform: translateY(-8px) scale(1.02);
    }
    80% {
        transform: translateY(-3px) scale(1.01);
    }
}

/* ===================================== */
/* 입력 필드 최적화 */
/* ===================================== */

/* 모바일 입력 필드 */
@media (max-width: 767px) {
    input[type="text"] {
        font-size: max(16px, 4vw); /* iOS 줌 방지 + 반응형 */
        min-height: max(48px, 8vh);
        padding: clamp(0.75rem, 3vw, 1rem);
        border-radius: clamp(0.5rem, 2vw, 0.75rem);
    }

    #result {
        font-size: clamp(1rem, 4.5vw, 1.25rem);
        min-height: max(4rem, 12vh);
        padding: clamp(1rem, 4vw, 1.5rem);
    }
}

/* 기본 입력 필드 스타일 */
input[type="text"] {
    -webkit-appearance: none;
    appearance: none;
    border: 2px solid #e5e7eb;
    border-radius: 0.75rem;
    transition: all 0.2s ease;
    outline: none;
}

input[type="text"]:focus {
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

#result {
    background: #f9fafb;
    border-radius: 1rem;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
}

/* ===================================== */
/* 📐 반응형 레이아웃 & 섹션 크기 조정 */
/* ===================================== */

/* 모바일 전용 헤더/메인/푸터 */
@media (max-width: 767px) {
    header {
        height: max(60px, 8vh);
        min-height: 50px;
        padding: clamp(0.5rem, 2vh, 1rem) clamp(1rem, 4vw, 1.5rem);
        width: 100%;
        max-width: 100%;
        overflow-x: hidden;
    }

    header h1 {
        font-size: clamp(1.125rem, 5vw, 1.5rem);
        width: 100%;
        max-width: 100%;
        word-wrap: break-word;
    }

    main {
        padding: clamp(0.75rem, 3vw, 1.5rem);
        padding-left: max(clamp(0.75rem, 3vw, 1.5rem), env(safe-area-inset-left));
        padding-right: max(clamp(0.75rem, 3vw, 1.5rem), env(safe-area-inset-right));
        padding-bottom: max(clamp(1rem, 4vh, 2rem), env(safe-area-inset-bottom));
        gap: clamp(0.75rem, 3vh, 1.5rem);
        height: calc(100vh - max(60px, 8vh) - max(40px, 6vh));
        overflow-y: auto;
        overflow-x: hidden;
        width: 100%;
        max-width: 100%;
    }

    section {
        padding: clamp(1rem, 4vw, 1.5rem);
        border-radius: clamp(0.75rem, 3vw, 1rem);
        width: 100%;
        max-width: 100%;
        overflow-x: hidden;
    }
    
    /* 모바일에서 flex 컨테이너와 아이템들의 간격 조정 */
    .flex.flex-wrap.justify-center {
        margin: 0 -0.25rem; /* 음수 마진으로 좌우 공간 확보 */
    }
    
    .mx-1 {
        margin-left: 0.25rem;
        margin-right: 0.25rem;
    }

    footer {
        height: max(40px, 6vh);
        min-height: 30px;
        padding: clamp(0.5rem, 2vh, 0.75rem);
        font-size: clamp(0.75rem, 3vw, 0.875rem);
        width: 100%;
        max-width: 100%;
        overflow-x: hidden;
    }
}

/* 기본 데스크톱 스타일 */
header {
    padding: 1rem;
    background: linear-gradient(135deg, #10b981, #3b82f6);
    width: 100%;
    max-width: 100%;
    overflow-x: hidden;
    box-sizing: border-box;
}

header h1 {
    font-size: 1.5rem;
    color: white;
    text-align: center;
    font-weight: bold;
}

main {
    padding: 1.5rem;
    gap: 1.5rem;
    display: flex;
    flex-direction: column;
    width: 100%;
    max-width: 100%;
    overflow-x: hidden;
}

section {
    background: white;
    border-radius: 1rem;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    padding: 1.5rem;
    width: 100%;
    max-width: 100%;
    overflow-x: hidden;
    box-sizing: border-box;
}

footer {
    padding: 1rem;
    text-align: center;
    color: #9ca3af;
    font-size: 0.875rem;
    width: 100%;
    max-width: 100%;
    overflow-x: hidden;
    box-sizing: border-box;
}

/* 데스크톱 레이아웃 최적화 */
@media (min-width: 768px) {
    header {
        height: auto;
        padding: 1.5rem 2rem;
    }
    
    header h1 {
        font-size: 1.75rem;
        max-width: 600px;
        margin: 0 auto;
    }
    
    main {
        max-width: 600px;
        margin: 0 auto;
        padding: 2rem;
        gap: 2rem;
        height: auto;
        min-height: calc(100vh - 200px);
        flex: 1;
        width: 100%;
        overflow-x: hidden;
    }
    
    section {
        padding: 2rem;
        border-radius: 1rem;
        width: 100%;
        max-width: 100%;
        overflow-x: hidden;
    }
    
    /* 데스크톱에서 flex 컨테이너 조정 */
    .flex.flex-wrap.justify-center {
        justify-content: flex-start; /* 데스크톱에서는 왼쪽 정렬 */
        margin: 0;
    }
    
    /* 데스크톱에서는 버튼들이 적당한 크기를 유지하도록 */
    .flex-1[class*="min-w-"] {
        flex: 0 1 auto; /* 데스크톱에서는 고정 크기 */
        max-width: none;
    }
    
    footer {
        height: auto;
        padding: 1rem;
        margin-top: auto;
    }
    
    footer > div {
        max-width: 600px;
        margin: 0 auto;
    }
    
    /* 데스크톱에서 캔버스 크기 조정 */
    #roulette-canvas {
        width: 350px;
        height: 350px;
        max-width: 350px;
        max-height: 350px;
    }
    
    /* 버튼 크기 조정 */
    button {
        font-size: 1rem;
        min-height: 48px;
        padding: 0.75rem 1.5rem;
    }
    
    #spin-button, #reset-button, #share-button {
        font-size: 1.125rem;
        min-height: 56px;
        padding: 1rem 2rem;
    }
    
    /* 입력 필드 크기 조정 */
    input[type="text"] {
        font-size: 1rem;
        min-height: 48px;
        padding: 0.75rem 1rem;
        border-radius: 0.5rem;
    }
    
    /* 결과 텍스트 크기 조정 */
    #result {
        font-size: 1.25rem;
        min-height: 4rem;
        padding: 1.5rem;
    }
    
    /* 아이템 태그 크기 조정 */
    .item-tag {
        font-size: 1rem;
        padding: 0.75rem 1rem;
        min-height: auto;
    }
    
    .remove-btn {
        width: 24px;
        height: 24px;
        min-width: 24px;
        min-height: 24px;
        margin: 0;
        font-size: 14px;
    }
}

/* 키보드 올라올 때 대응 */
@media (max-height: 600px) and (orientation: portrait) {
    main {
        padding-top: 0.5rem;
        padding-bottom: 0.5rem;
    }
    
    main > section {
        margin-bottom: 0.75rem;
    }
}

/* ===================================== */
/* 다크모드 대응 */
/* ===================================== */

@media (prefers-color-scheme: dark) {
    body {
        background-color: #1f2937;
    }
    
    section {
        background-color: #374151 !important;
        color: white;
    }
    
    input[type="text"] {
        background-color: #4b5563;
        color: white;
        border-color: #6b7280;
    }
    
    input[type="text"]::placeholder {
        color: #9ca3af;
    }
    
    .result-highlight {
        background: linear-gradient(135deg, #f59e0b, #ef4444);
        color: white;
    }
}

/* ===================================== */
/* 접근성 */
/* ===================================== */

.sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
}

/* 고대비 모드 대응 */
@media (prefers-contrast: high) {
    .item-tag {
        border: 2px solid white;
    }
    
    button {
        border: 2px solid currentColor;
    }
}

/* 움직임 줄이기 설정 시 애니메이션 비활성화 */
@media (prefers-reduced-motion: reduce) {
    *,
    *::before,
    *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
        scroll-behavior: auto !important;
    }
}
    </style>
</head>
<body>
    <div class="min-h-screen bg-gray-100" style="width: 100%; max-width: 100vw; overflow-x: hidden;">
        <!-- 컴팩트한 헤더 -->
        <header class="bg-gradient-to-r from-green-500 to-blue-500 text-white px-4 md:px-8 py-3 md:py-6 shadow-lg">
            <div class="max-w-full md:max-w-2xl mx-auto" style="width: 100%; max-width: 100%; overflow-x: hidden;">
                <h1 class="text-xl md:text-3xl font-bold text-center">
                    🎯 결정장애 돌림판
                </h1>
            </div>
        </header>

        <!-- 메인 콘텐츠 영역 - 반응형 컨테이너 -->
        <main class="max-w-full md:max-w-2xl mx-auto p-4 md:p-8 space-y-4 md:space-y-6 min-h-[calc(100vh-60px)] md:min-h-0 flex flex-col" style="width: 100%; max-width: 100%; overflow-x: hidden;">
            <!-- 항목 입력 섹션 -->
            <section class="bg-white rounded-xl shadow-lg p-4 md:p-6">
                <div class="flex flex-wrap justify-center gap-2 md:gap-3 mb-3 md:mb-4">
                    <input 
                        type="text" 
                        id="item-input"
                        placeholder="항목 입력 (예: 치킨)"
                        class="flex-grow min-w-0 px-4 py-3 md:px-5 md:py-4 text-lg md:text-xl border-2 border-gray-200 rounded-xl focus:outline-none focus:border-blue-500 focus:ring-2 focus:ring-blue-100 mx-1"
                        aria-label="돌림판에 추가할 항목을 입력하세요"
                    />
                    <button 
                        type="button"
                        id="add-button"
                        class="px-6 py-3 md:px-8 md:py-4 bg-blue-500 text-white font-semibold rounded-xl hover:bg-blue-600 active:bg-blue-700 transition-colors min-w-[80px] md:min-w-[100px] text-lg md:text-xl mx-1"
                        aria-label="항목 추가"
                    >
                        ➕
                    </button>
                </div>
            
                <!-- 추가된 항목들 -->
                <div id="items-list" class="flex flex-wrap gap-2">
                    <!-- JavaScript로 동적 생성 -->
                </div>
            </section>
            
            <!-- 즐겨찾기 섹션 -->
            <section class="bg-white rounded-xl shadow-lg p-4 md:p-6">
                <div class="flex items-center gap-2 mb-3 md:mb-4">
                    <span class="text-lg md:text-xl font-semibold">💾</span>
                    <h3 class="text-lg md:text-xl font-semibold text-gray-800">즐겨찾기</h3>
                </div>
                
                <!-- 저장 영역 -->
                <div class="flex flex-wrap justify-center gap-2 md:gap-3 mb-4 md:mb-6">
                    <input 
                        type="text" 
                        id="favorite-name-input"
                        placeholder="돌림판 이름"
                        class="flex-grow min-w-0 px-4 py-3 md:px-5 md:py-4 text-lg md:text-xl border-2 border-gray-200 rounded-xl focus:outline-none focus:border-purple-500 focus:ring-2 focus:ring-purple-100 mx-1"
                    />
                    <button 
                        type="button"
                        id="save-favorite-button"
                        class="px-6 py-3 md:px-8 md:py-4 bg-purple-500 text-white font-semibold rounded-xl hover:bg-purple-600 active:bg-purple-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed min-w-[80px] md:min-w-[100px] text-lg md:text-xl mx-1"
                        disabled
                    >
                        💾
                    </button>
                </div>
                
                <!-- 저장된 즐겨찾기 목록 -->
                <div id="favorites-list" class="space-y-2">
                    <!-- JavaScript로 동적 생성 -->
                </div>
                
                <!-- 전체 삭제 버튼 -->
                <button 
                    type="button"
                    id="clear-all-favorites-button"
                    class="w-full mt-3 py-2 text-red-500 text-sm font-medium hover:bg-red-50 rounded-lg transition-colors"
                    style="display: none;"
                >
                    🗑️ 전체 삭제
                </button>
            </section>

            <!-- 돌림판 섹션 - 메인 영역 -->
            <section class="bg-white rounded-xl shadow-lg p-4 md:p-8 flex-1 flex flex-col justify-center">
                <!-- 캔버스 영역 -->
                <div class="flex justify-center mb-4 md:mb-8 relative">
                    <!-- 고정 화살표 -->
                    <div class="absolute top-0 left-1/2 transform -translate-x-1/2 z-20">
                        <div class="arrow-pointer"></div>
                    </div>
                    
                    <canvas 
                        id="roulette-canvas"
                        width="280"
                        height="280"
                        class="border-4 border-gray-200 rounded-full shadow-lg relative z-10 max-w-full"
                        aria-label="돌림판 영역"
                    >
                        돌림판을 표시하려면 JavaScript가 필요합니다.
                    </canvas>
                </div>

                <!-- 돌리기, 리셋, 공유 버튼 -->
                <div class="flex flex-wrap justify-center gap-3 md:gap-6">
                    <button 
                        type="button"
                        id="spin-button"
                        class="flex-1 min-w-[100px] max-w-[200px] py-4 md:py-6 bg-green-500 text-white text-lg md:text-xl font-bold rounded-xl hover:bg-green-600 active:bg-green-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed shadow-lg mx-1"
                        aria-label="돌림판 돌리기"
                        disabled
                    >
                        <div class="flex items-center justify-center gap-2">
                            <span class="text-xl md:text-2xl">🎯</span>
                            <span class="hidden sm:inline">돌리기!</span>
                            <span class="sm:hidden">돌리기</span>
                        </div>
                    </button>
                    <button 
                        type="button"
                        id="reset-button"
                        class="flex-1 min-w-[100px] max-w-[200px] py-4 md:py-6 bg-red-500 text-white text-lg md:text-xl font-bold rounded-xl hover:bg-red-600 active:bg-red-700 transition-colors shadow-lg mx-1"
                        aria-label="돌림판 리셋하기"
                    >
                        <div class="flex items-center justify-center gap-2">
                            <span class="text-xl md:text-2xl">🔄</span>
                            <span>리셋</span>
                        </div>
                    </button>
                    <button 
                        type="button"
                        id="share-button"
                        class="flex-1 min-w-[100px] max-w-[200px] py-4 md:py-6 bg-blue-500 text-white text-lg md:text-xl font-bold rounded-xl hover:bg-blue-600 active:bg-blue-700 transition-colors shadow-lg mx-1"
                        aria-label="돌림판 링크 복사"
                    >
                        <div class="flex items-center justify-center gap-2">
                            <span class="text-xl md:text-2xl">🔗</span>
                            <span>공유</span>
                        </div>
                    </button>
                </div>
            </section>

            <!-- 결과 섹션 -->
            <section class="bg-white rounded-xl shadow-lg p-4 md:p-6">
                <div class="flex items-center gap-2 mb-3 md:mb-4">
                    <span class="text-lg md:text-xl font-semibold">🎯</span>
                    <h3 class="text-lg md:text-xl font-semibold text-gray-800">결과</h3>
                </div>
                <div 
                    id="result"
                    class="text-center text-lg md:text-xl text-gray-600 min-h-[4rem] md:min-h-[5rem] flex items-center justify-center bg-gray-50 rounded-xl p-4 md:p-6"
                    aria-live="polite"
                    aria-label="돌림판 결과"
                >
                    항목을 추가하고 돌림판을 돌려보세요!
                </div>
            </section>
        </main>

        <!-- 컴팩트한 푸터 -->
        <footer class="text-center py-3 md:py-6 text-gray-400 text-sm md:text-base">
            <div class="max-w-full md:max-w-2xl mx-auto" style="width: 100%; max-width: 100%; overflow-x: hidden;">
                💫 결정장애 해결사
            </div>
        </footer>
    </div>

    <script>
// ===================================================================
// 결정장애 돌림판 - 최종 완벽 버전
// 설계: 수학적으로 완벽한 계산식 + 완전 분리된 로직 + 리셋 기능
// ===================================================================

// [1. 기본 변수 및 상태 설정]
// DOM 요소들 가져오기
const canvas = document.getElementById('roulette-canvas');
const ctx = canvas.getContext('2d');
const itemInput = document.getElementById('item-input');
const addButton = document.getElementById('add-button');
const spinButton = document.getElementById('spin-button');
const resetButton = document.getElementById('reset-button');
const itemsList = document.getElementById('items-list');
const resultElement = document.getElementById('result');
const arrowPointer = document.querySelector('.arrow-pointer');

// 즐겨찾기 관련 DOM 요소들
const favoriteNameInput = document.getElementById('favorite-name-input');
const saveFavoriteButton = document.getElementById('save-favorite-button');
const favoritesList = document.getElementById('favorites-list');
const clearAllFavoritesButton = document.getElementById('clear-all-favorites-button');

// 상태 변수들
let items = []; // 항목 배열
let currentRotation = 0; // 현재 돌림판의 총 회전 각도 (라디안)
let isSpinning = false; // 회전 중복 방지 플래그
let animationId = null; // 애니메이션 ID
let preSelectedWinner = null; // 미리 결정된 승자

// ===================================================================
// 🚀 카카오톡 인앱 브라우저 자동 전환 기능
// ===================================================================

// 카카오톡 인앱 브라우저 감지 및 외부 브라우저로 전환
const handleKakaoInAppBrowser = () => {
    const userAgent = navigator.userAgent || navigator.vendor || window.opera;
    const isKakaoTalk = userAgent.includes('KAKAOTALK');
    
    if (isKakaoTalk) {
        console.log('🔍 카카오톡 인앱 브라우저 감지됨');
        
        // iOS/Android 구분
        const isIOS = /iPad|iPhone|iPod/.test(userAgent);
        const isAndroid = /Android/.test(userAgent);
        
        if (isAndroid) {
            // 안드로이드: Chrome Intent URL로 자동 전환
            console.log('📱 안드로이드 - Chrome으로 자동 전환 시도');
            const currentUrl = encodeURIComponent(window.location.href);
            const chromeIntent = `intent://${window.location.host}${window.location.pathname}${window.location.search}#Intent;scheme=https;package=com.android.chrome;end`;
            
            try {
                window.location.href = chromeIntent;
                // 2초 후에도 카카오톡에 있다면 수동 안내
                setTimeout(() => {
                    if (userAgent.includes('KAKAOTALK')) {
                        showExternalBrowserGuide('Android');
                    }
                }, 2000);
            } catch (error) {
                console.warn('Chrome Intent 실행 실패:', error);
                showExternalBrowserGuide('Android');
            }
        } else if (isIOS) {
            // iOS: 수동 안내 (자동 전환 불가)
            console.log('🍎 iOS - Safari 전환 안내 표시');
            showExternalBrowserGuide('iOS');
        } else {
            // 기타 플랫폼
            showExternalBrowserGuide('기타');
        }
        
        return true; // 카카오톡 브라우저임을 반환
    }
    
    return false; // 일반 브라우저임을 반환
};

// 외부 브라우저 이용 안내 표시
const showExternalBrowserGuide = (platform) => {
    const messages = {
        'Android': '📱 더 나은 이용을 위해 Chrome 브라우저에서 열어주세요!\n\n1. 우측 상단 ⋮ 메뉴 클릭\n2. "다른 브라우저에서 열기" 선택\n3. Chrome 선택',
        'iOS': '🍎 더 나은 이용을 위해 Safari에서 열어주세요!\n\n1. 우측 하단 Safari 아이콘 클릭\n또는\n1. 우측 상단 ⋯ 메뉴 클릭\n2. "Safari에서 열기" 선택',
        '기타': '🌐 더 나은 이용을 위해 기본 브라우저에서 열어주세요!\n\n카카오톡 내장 브라우저에서는\n일부 기능이 제한될 수 있습니다.'
    };
    
    const message = messages[platform] || messages['기타'];
    
    // 모달 스타일 알림창 생성
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 9999;
        padding: 20px;
        box-sizing: border-box;
    `;
    
    const content = document.createElement('div');
    content.style.cssText = `
        background: white;
        border-radius: 16px;
        padding: 24px;
        max-width: 90%;
        text-align: center;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    `;
    
    // 안전하게 요소 생성
    const iconDiv = document.createElement('div');
    iconDiv.style.cssText = 'font-size: 1.5rem; margin-bottom: 16px;';
    iconDiv.textContent = '🎯';
    
    const titleH3 = document.createElement('h3');
    titleH3.style.cssText = 'margin: 0 0 16px 0; font-size: 1.2rem; color: #333;';
    titleH3.textContent = '결정장애 돌림판';
    
    const messageP = document.createElement('p');
    messageP.style.cssText = 'margin: 0 0 20px 0; line-height: 1.5; color: #666; white-space: pre-line;';
    messageP.textContent = message; // XSS 방지를 위해 textContent 사용
    
    const confirmBtn = document.createElement('button');
    confirmBtn.style.cssText = 'background: #4CAF50; color: white; border: none; padding: 12px 24px; border-radius: 8px; font-size: 1rem; cursor: pointer;';
    confirmBtn.textContent = '확인';
    confirmBtn.addEventListener('click', () => modal.remove());
    
    content.appendChild(iconDiv);
    content.appendChild(titleH3);
    content.appendChild(messageP);
    content.appendChild(confirmBtn);
    
    modal.appendChild(content);
    document.body.appendChild(modal);
    
    // 3초 후 자동으로 알림창 제거 (선택사항)
    setTimeout(() => {
        if (modal && modal.parentElement) {
            modal.remove();
        }
    }, 10000);
};

// 반응형 캔버스 크기 계산 (상대 단위 적용)
const initializeCanvas = () => {
    const isDesktop = window.innerWidth >= 768;
    
    // 화면 크기에 따른 동적 크기 계산
    let maxSize;
    
    if (isDesktop) {
        // 데스크톱: 고정 크기로 안정적인 표시
        maxSize = 350;
    } else {
        // 모바일: 뷰포트 기준 상대 크기
        const containerWidth = canvas.parentElement.clientWidth;
        maxSize = Math.min(
            containerWidth - 40,
            Math.min(window.innerWidth * 0.7, window.innerHeight * 0.35),
            280
        );
    }
    
    canvas.width = maxSize;
    canvas.height = maxSize;
    canvas.style.width = maxSize + 'px';
    canvas.style.height = maxSize + 'px';
    
    return {
        centerX: maxSize / 2,
        centerY: maxSize / 2,
        radius: maxSize / 2 - 20
    };
};

// 캔버스 크기 정보 (동적으로 계산)
let canvasInfo = initializeCanvas();

// ===================================================================
// [2. drawRoulette() 함수: 오직 그리기만 담당]
// 역할: currentRotation 값을 기반으로 현재 상태의 돌림판을 그리기
// ===================================================================
const drawRoulette = () => {
    // 캔버스 클리어
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    if (items.length === 0) {
        // 빈 상태 표시
        drawEmptyWheel();
        return;
    }
    
    // 좌표계 변환: ctx.save(), ctx.translate(), ctx.rotate(), ctx.restore() 패턴
    ctx.save();
    
    // 캔버스 중심으로 좌표 이동
    ctx.translate(canvasInfo.centerX, canvasInfo.centerY);
    
    // currentRotation만큼 캔버스 자체를 회전
    ctx.rotate(currentRotation);
    
    // 조각 그리기: items 배열을 순회하며 각 조각의 색상과 텍스트를 정확한 위치에 그리기
    const sliceAngle = (2 * Math.PI) / items.length;
    
    items.forEach((item, index) => {
        // 각 조각의 시작과 끝 각도 계산 (12시 방향부터 시작)
        const startAngle = index * sliceAngle - Math.PI / 2;
        const endAngle = (index + 1) * sliceAngle - Math.PI / 2;
        
        // 조각 색상 생성
        const hue = (index * 360 / items.length) % 360;
        const sliceColor = `hsl(${hue}, 70%, 60%)`;
        
        // 조각 그리기
        drawSlice(startAngle, endAngle, sliceColor);
        
        // 텍스트를 조각의 중앙에 올바른 방향으로 그리기
        const textAngle = startAngle + sliceAngle / 2;
        drawSliceText(item, textAngle);
    });
    
    // 중앙 원 그리기
    drawCenterCircle();
    
    // 좌표계 복원
    ctx.restore();
};

// 빈 돌림판 그리기
const drawEmptyWheel = () => {
    ctx.fillStyle = '#f3f4f6';
    ctx.beginPath();
    ctx.arc(canvasInfo.centerX, canvasInfo.centerY, canvasInfo.radius, 0, 2 * Math.PI);
    ctx.fill();
    
    ctx.fillStyle = '#9ca3af';
    ctx.font = `${Math.max(14, canvasInfo.radius / 10)}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('항목을 추가해주세요', canvasInfo.centerX, canvasInfo.centerY);
};

// 개별 조각 그리기
const drawSlice = (startAngle, endAngle, color) => {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.arc(0, 0, canvasInfo.radius, startAngle, endAngle);
    ctx.closePath();
    ctx.fill();
    
    // 테두리 그리기
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = Math.max(2, canvasInfo.radius / 60);
    ctx.stroke();
};

// 조각 텍스트 그리기 (정확한 위치와 방향)
const drawSliceText = (text, textAngle) => {
    const textRadius = canvasInfo.radius * 0.75;
    const textX = Math.cos(textAngle) * textRadius;
    const textY = Math.sin(textAngle) * textRadius;
    
    ctx.save();
    ctx.translate(textX, textY);
    ctx.rotate(textAngle + Math.PI / 2);
    
    // 동적 폰트 크기 계산
    const fontSize = Math.max(10, Math.min(16, canvasInfo.radius / 10));
    
    // 텍스트 그림자
    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
    ctx.font = `bold ${fontSize}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, 1, 1);
    
    // 실제 텍스트
    ctx.fillStyle = '#ffffff';
    ctx.fillText(text, 0, 0);
    
    ctx.restore();
};

// 중앙 원 그리기
const drawCenterCircle = () => {
    const centerRadius = Math.max(8, canvasInfo.radius / 15);
    
    ctx.fillStyle = '#374151';
    ctx.beginPath();
    ctx.arc(0, 0, centerRadius, 0, 2 * Math.PI);
    ctx.fill();
    
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = Math.max(1, centerRadius / 8);
    ctx.stroke();
};

// ===================================================================
// [3. spin() 함수: 가장 정확한 목표 계산 및 실행]
// ===================================================================
const spin = () => {
    // 중복 실행 방지
    if (isSpinning || items.length === 0) return;
    
    isSpinning = true;
    updateSpinButtonState();
    updateArrowState('spinning');
    
    // 🔄 중요: 새로운 스핀 시작 전 회전 각도를 0으로 리셋 (누적 오류 방지)
    currentRotation = 0;
    drawRoulette(); // 리셋된 상태로 돌림판 다시 그리기
    
    console.log(`🔄 회전 각도 리셋: currentRotation = 0`);
    
    // 1단계: 승자 결정 (애니메이션 시작 전)
    const winnerIndex = Math.floor(Math.random() * items.length);
    const winnerItem = items[winnerIndex];
    preSelectedWinner = { index: winnerIndex, item: winnerItem };
    
    console.log(`🎯 === 승자 결정 ===`);
    console.log(`🏆 승자: items[${winnerIndex}] = "${winnerItem}"`);
    
    // 2단계: 최종 목표 각도 계산 (항상 0도 기준으로 계산)
    const sliceAngle = (2 * Math.PI) / items.length;
    
    // 🧮 핵심 공식: 승자 조각의 중앙이 12시 방향에 오기 위한 최종 회전 각도
    // "10바퀴를 돌고, 승자 조각의 시작점까지 되감고, 다시 조각의 절반만큼 더 되감는"
    // 항상 0도를 기준으로 계산하므로 currentRotation을 더하지 않음
    let winnerTargetRotation = (2 * Math.PI * 10) - (winnerIndex * sliceAngle) - (sliceAngle / 2);
    
    // 자연스러움을 위한 약간의 랜덤 값 추가 (조각 중앙에 정확히 멈추지 않도록)
    const randomOffset = (Math.random() - 0.5) * (sliceAngle * 0.3); // ±15% 랜덤
    winnerTargetRotation += randomOffset;
    
    // 최종 목표 회전 (0도에서 시작하므로 currentRotation 더하지 않음)
    const finalTargetRotation = winnerTargetRotation;
    
    console.log(`📐 조각 크기: ${(sliceAngle * 180 / Math.PI).toFixed(1)}도`);
    console.log(`🎯 목표 회전: ${(winnerTargetRotation * 180 / Math.PI).toFixed(1)}도`);
    console.log(`🚀 최종 목표: ${(finalTargetRotation * 180 / Math.PI).toFixed(1)}도`);
    
    // 3단계: 애니메이션 및 결과 표시
    startSpinAnimation(finalTargetRotation);
};

// 스핀 애니메이션 시작
const startSpinAnimation = (targetRotation) => {
    const startRotation = currentRotation;
    const totalRotation = targetRotation - startRotation;
    const duration = 5000; // 5초
    const startTime = performance.now();
    
    console.log(`🎬 애니메이션 시작 (${duration/1000}초, ${(totalRotation * 180 / Math.PI).toFixed(1)}도 회전)`);
    
    const animate = (currentTime) => {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // 부드럽게 감속하는 easing 함수
        const easedProgress = easeOutCubic(progress);
        
        // currentRotation 값을 업데이트
        currentRotation = startRotation + (totalRotation * easedProgress);
        
        // 매 프레임마다 drawRoulette() 호출
        drawRoulette();
        
        if (progress < 1) {
            animationId = safeRequestAnimationFrame(animate);
        } else {
            // 애니메이션 완료
            finishSpin();
        }
    };
    
    animationId = safeRequestAnimationFrame(animate);
};

// Easing 함수 (점진적 감속)
const easeOutCubic = (t) => {
    return 1 - Math.pow(1 - t, 3);
};

// 스핀 완료 처리
const finishSpin = () => {
    isSpinning = false;
    animationId = null;
    
    console.log(`🛑 애니메이션 완료`);
    console.log(`📐 최종 각도: ${(currentRotation * 180 / Math.PI).toFixed(1)}도`);
    console.log(`🎉 결과: "${preSelectedWinner.item}"`);
    
    // 결과 표시 (1단계에서 결정한 승자 사용, 다시 계산 금지)
    showResult(preSelectedWinner.item);
    
    // UI 상태 복원
    updateSpinButtonState();
    updateArrowState('result');
    
    // 화살표 강조 효과 제거
    setTimeout(() => {
        updateArrowState('normal');
    }, 2000);
};

// ===================================================================
// [4. reset() 함수: 리셋 기능]
// ===================================================================
const reset = () => {
    // 애니메이션 중이면 중단
    if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
    }
    
    // 상태 초기화
    items = []; // items 배열 비우기
    currentRotation = 0; // currentRotation = 0으로 초기화
    isSpinning = false;
    preSelectedWinner = null;
    
    // UI 업데이트
    updateItemsList();
    drawRoulette(); // 깨끗한 돌림판을 다시 그리기
    updateSpinButtonState();
    updateSaveFavoriteButton(); // 저장 버튼 상태 업데이트
    updateArrowState('normal');
    
    // 결과 텍스트 비우기
    resultElement.textContent = '항목을 추가하고 돌림판을 돌려보세요!';
    resultElement.className = 'text-center text-lg text-gray-600 min-h-[3rem] flex items-center justify-center';
    
    // 즐겨찾기 입력창 초기화
    favoriteNameInput.value = '';
    
    // 입력창 포커스
    itemInput.focus();
    
    console.log(`🔄 === 리셋 완료 ===`);
    console.log(`✅ 모든 상태가 초기화되었습니다.`);
};

// ===================================================================
// [5. 즐겨찾기 기능]
// ===================================================================

// localStorage에서 즐겨찾기 목록 가져오기
const getFavorites = () => {
    try {
        const favorites = safeLocalStorage.getItem('roulette-favorites');
        return favorites ? JSON.parse(favorites) : [];
    } catch (error) {
        handleGlobalError(error, 'Storage');
        return [];
    }
};

// localStorage에 즐겨찾기 목록 저장
const setFavorites = (favorites) => {
    const success = safeLocalStorage.setItem('roulette-favorites', JSON.stringify(favorites));
    if (success) {
        console.log('즐겨찾기 저장 완료');
    } else {
        alert('저장 공간이 부족하거나 저장에 실패했습니다. 일부 즐겨찾기를 삭제해주세요.');
    }
};

// 현재 돌림판을 즐겨찾기로 저장
const saveFavorite = () => {
    const name = favoriteNameInput.value.trim();
    
    if (!name) {
        alert('돌림판 이름을 입력해주세요!');
        favoriteNameInput.focus();
        return;
    }
    
    if (items.length === 0) {
        alert('저장할 항목이 없습니다!');
        return;
    }
    
    const favorites = getFavorites();
    
    // 동일한 이름이 있는지 확인
    const existingIndex = favorites.findIndex(fav => fav.name === name);
    
    if (existingIndex !== -1) {
        const overwrite = confirm(`"${name}" 돌림판이 이미 있습니다. 덮어쓰시겠습니까?`);
        if (!overwrite) {
            favoriteNameInput.focus();
            return;
        }
        // 기존 항목 업데이트
        favorites[existingIndex] = {
            name: name,
            items: [...items],
            createdAt: Date.now()
        };
    } else {
        // 새 항목 추가
        favorites.push({
            name: name,
            items: [...items],
            createdAt: Date.now()
        });
    }
    
    setFavorites(favorites);
    favoriteNameInput.value = '';
    updateFavoritesList();
    updateSaveFavoriteButton();
    
    console.log(`💾 즐겨찾기 저장: "${name}" (${items.length}개 항목)`);
    
    // 성공 메시지
    const successMsg = document.createElement('div');
    successMsg.className = 'text-xs text-green-600 mt-1';
    successMsg.textContent = `✅ "${name}" 저장 완료!`;
    favoriteNameInput.parentNode.appendChild(successMsg);
    
    setTimeout(() => {
        successMsg.remove();
    }, 2000);
};

// 저장된 돌림판 불러오기
const loadFavorite = (index) => {
    const favorites = getFavorites();
    
    if (index < 0 || index >= favorites.length) {
        alert('존재하지 않는 즐겨찾기입니다.');
        return;
    }
    
    const favorite = favorites[index];
    
    // 현재 항목이 있으면 확인
    if (items.length > 0) {
        const confirm = window.confirm(`현재 항목들이 "${favorite.name}" 돌림판으로 바뀝니다. 계속하시겠습니까?`);
        if (!confirm) return;
    }
    
    // 항목 불러오기
    items = [...favorite.items];
    
    // 돌림판 상태 초기화
    currentRotation = 0;
    
    // UI 업데이트
    updateItemsList();
    drawRoulette();
    updateSpinButtonState();
    
    // 결과 영역 초기화
    resultElement.textContent = '항목을 추가하고 돌림판을 돌려보세요!';
    resultElement.className = 'text-center text-lg text-gray-600 min-h-[3rem] flex items-center justify-center';
    
    console.log(`📂 즐겨찾기 불러오기: "${favorite.name}" (${favorite.items.length}개 항목)`);
    
    // 성공 메시지
    const successMsg = document.createElement('div');
    successMsg.className = 'text-xs text-blue-600 mt-1 text-center';
    successMsg.textContent = `📂 "${favorite.name}" 불러오기 완료!`;
    favoritesList.appendChild(successMsg);
    
    setTimeout(() => {
        successMsg.remove();
    }, 2000);
};

// 특정 즐겨찾기 삭제
const deleteFavorite = (index) => {
    const favorites = getFavorites();
    
    if (index < 0 || index >= favorites.length) {
        alert('존재하지 않는 즐겨찾기입니다.');
        return;
    }
    
    const favorite = favorites[index];
    const confirmDelete = confirm(`"${favorite.name}" 돌림판을 삭제하시겠습니까?`);
    
    if (!confirmDelete) return;
    
    favorites.splice(index, 1);
    setFavorites(favorites);
    updateFavoritesList();
    
    console.log(`🗑️ 즐겨찾기 삭제: "${favorite.name}"`);
};

// 모든 즐겨찾기 삭제
const clearAllFavorites = () => {
    const favorites = getFavorites();
    
    if (favorites.length === 0) {
        alert('삭제할 즐겨찾기가 없습니다.');
        return;
    }
    
    const confirmDelete = confirm(`모든 즐겨찾기 돌림판(${favorites.length}개)을 삭제하시겠습니까?\n이 작업은 되돌릴 수 없습니다.`);
    
    if (!confirmDelete) return;
    
    setFavorites([]);
    updateFavoritesList();
    
    console.log(`🗑️ 모든 즐겨찾기 삭제 (${favorites.length}개)`);
    
    alert('모든 즐겨찾기가 삭제되었습니다.');
};

// 즐겨찾기 목록 UI 업데이트
const updateFavoritesList = () => {
    const favorites = getFavorites();
    favoritesList.innerHTML = '';
    
    if (favorites.length === 0) {
        favoritesList.innerHTML = '<div class="text-sm text-gray-400 text-center py-4 bg-gray-50 rounded-lg">저장된 돌림판이 없습니다.</div>';
        clearAllFavoritesButton.style.display = 'none';
        return;
    }
    
    clearAllFavoritesButton.style.display = 'inline';
    
    favorites.forEach((favorite, index) => {
        const favoriteItem = document.createElement('div');
        favoriteItem.className = 'flex items-center justify-between bg-gray-50 px-4 py-3 rounded-xl shadow-sm';
        
        // 안전하게 요소 생성
        const mainDiv = document.createElement('div');
        mainDiv.className = 'flex-1 min-w-0';
        
        const nameDiv = document.createElement('div');
        nameDiv.className = 'text-base font-semibold text-gray-800 truncate';
        nameDiv.textContent = favorite.name; // XSS 방지를 위해 textContent 사용
        
        const infoDiv = document.createElement('div');
        infoDiv.className = 'text-sm text-gray-500';
        infoDiv.textContent = `${favorite.items.length}개 항목 • ${new Date(favorite.createdAt).toLocaleDateString()}`;
        
        mainDiv.appendChild(nameDiv);
        mainDiv.appendChild(infoDiv);
        
        const buttonsDiv = document.createElement('div');
        buttonsDiv.className = 'flex gap-2 ml-2';
        
        const loadBtn = document.createElement('button');
        loadBtn.className = 'load-favorite-btn px-3 py-2 bg-blue-500 text-white text-sm font-semibold rounded-lg hover:bg-blue-600 active:bg-blue-700 transition-colors';
        loadBtn.dataset.index = index;
        loadBtn.textContent = '📂';
        loadBtn.setAttribute('aria-label', `${favorite.name} 돌림판 불러오기`);
        
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'delete-favorite-btn px-3 py-2 bg-red-500 text-white text-sm font-semibold rounded-lg hover:bg-red-600 active:bg-red-700 transition-colors';
        deleteBtn.dataset.index = index;
        deleteBtn.textContent = '🗑️';
        deleteBtn.setAttribute('aria-label', `${favorite.name} 돌림판 삭제`);
        
        buttonsDiv.appendChild(loadBtn);
        buttonsDiv.appendChild(deleteBtn);
        
        favoriteItem.appendChild(mainDiv);
        favoriteItem.appendChild(buttonsDiv);
        
        favoritesList.appendChild(favoriteItem);
    });
    
    // 이벤트 리스너 추가
    document.querySelectorAll('.load-favorite-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const index = parseInt(e.target.dataset.index);
            loadFavorite(index);
        });
    });
    
    document.querySelectorAll('.delete-favorite-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const index = parseInt(e.target.dataset.index);
            deleteFavorite(index);
        });
    });
};

// 저장 버튼 상태 업데이트
const updateSaveFavoriteButton = () => {
    const hasItems = items.length > 0;
    const hasName = favoriteNameInput.value.trim().length > 0;
    
    saveFavoriteButton.disabled = !hasItems || !hasName;
};

// ===================================================================
// [6. 기타 유틸리티 함수들]
// ===================================================================

// 항목 추가
const addItem = () => {
    try {
        const value = validateAndSanitizeInput(itemInput.value);
        
        if (!value) {
            alert('항목을 입력해주세요!');
            itemInput.focus();
            return;
        }
        
        if (items.includes(value)) {
            alert('이미 추가된 항목입니다!');
            itemInput.focus();
            return;
        }
        
        if (items.length >= 20) {
            alert('최대 20개까지만 추가할 수 있습니다!');
            return;
        }
    } catch (error) {
        alert(error.message);
        itemInput.focus();
        return;
    }
    
    items.push(value);
    itemInput.value = '';
    itemInput.focus();
    
    // 🔄 항목 추가 후 돌림판 각도를 0으로 리셋 (구성 변경으로 인한 오류 방지)
    currentRotation = 0;
    
    updateItemsList();
    drawRoulette(); // 초기 상태로 돌림판 다시 그리기
    updateSpinButtonState();
    updateSaveFavoriteButton(); // 저장 버튼 상태 업데이트
    enhanceRouletteAccessibility(); // 캔버스 접근성 업데이트
    
    // 접근성 알림
    announceToScreenReader(`"${value}" 항목이 추가되었습니다. 총 ${items.length}개 항목`);
    
    console.log(`➕ 항목 추가: "${value}" (총 ${items.length}개)`);
    console.log(`🔄 돌림판 각도 리셋: currentRotation = 0`);
};

// 항목 삭제
const removeItem = (index) => {
    const removedItem = items[index];
    items.splice(index, 1);
    
    // 🔄 항목 제거 후 돌림판 각도를 0으로 리셋 (구성 변경으로 인한 오류 방지)
    currentRotation = 0;
    
    updateItemsList();
    drawRoulette(); // 초기 상태로 돌림판 다시 그리기
    updateSpinButtonState();
    updateSaveFavoriteButton(); // 저장 버튼 상태 업데이트
    enhanceRouletteAccessibility(); // 캔버스 접근성 업데이트
    
    if (items.length === 0) {
        resultElement.textContent = '항목을 추가하고 돌림판을 돌려보세요!';
        resultElement.className = 'text-center text-lg text-gray-600 min-h-[3rem] flex items-center justify-center';
    }
    
    // 접근성 알림
    announceToScreenReader(`"${removedItem}" 항목이 삭제되었습니다. ${items.length > 0 ? `총 ${items.length}개 항목` : '항목이 없습니다'}`);
    
    console.log(`➖ 항목 제거: "${removedItem}" (총 ${items.length}개)`);
    console.log(`🔄 돌림판 각도 리셋: currentRotation = 0`);
};

// 항목 목록 UI 업데이트
const updateItemsList = () => {
    itemsList.innerHTML = '';
    
    if (items.length === 0) {
        itemsList.innerHTML = '<span class="text-gray-400 text-sm">아직 추가된 항목이 없습니다.</span>';
        return;
    }
    
    items.forEach((item, index) => {
        const tag = document.createElement('div');
        tag.className = 'item-tag';
        // 안전하게 요소 생성
        const itemSpan = document.createElement('span');
        itemSpan.textContent = item; // XSS 방지를 위해 textContent 사용
        
        const removeBtn = document.createElement('button');
        removeBtn.className = 'remove-btn';
        removeBtn.textContent = '×';
        removeBtn.setAttribute('aria-label', `${item} 삭제`);
        removeBtn.setAttribute('title', `${item} 삭제`);
        removeBtn.addEventListener('click', () => removeItem(index));
        
        tag.appendChild(itemSpan);
        tag.appendChild(removeBtn);
        itemsList.appendChild(tag);
    });
    
    // 저장 버튼 상태 업데이트 (항목 목록이 변경되었으므로)
    updateSaveFavoriteButton();
};

// 돌리기 버튼 상태 업데이트
const updateSpinButtonState = () => {
    const shouldDisable = items.length === 0 || isSpinning;
    spinButton.disabled = shouldDisable;
    
    if (isSpinning) {
        spinButton.textContent = '돌리는 중...';
        spinButton.classList.add('animate-pulse');
    } else {
        spinButton.innerHTML = `
            <div class="flex items-center justify-center gap-2">
                <span>🎯</span>
                <span>돌리기!</span>
            </div>
        `;
        spinButton.classList.remove('animate-pulse');
    }
};

// 화살표 상태 업데이트
const updateArrowState = (state) => {
    arrowPointer.classList.remove('spinning', 'result');
    
    if (state === 'spinning') {
        arrowPointer.classList.add('spinning');
    } else if (state === 'result') {
        arrowPointer.classList.add('result');
    }
};

// 결과 표시
const showResult = (selectedItem) => {
    resultElement.textContent = `🎯 결과: ${selectedItem}`;
    resultElement.className = 'text-center result-highlight min-h-[3rem] flex items-center justify-center';
    
    // 접근성을 위한 스크린 리더 알림
    setTimeout(() => {
        const announcement = document.createElement('div');
        announcement.className = 'sr-only';
        announcement.setAttribute('aria-live', 'assertive');
        announcement.textContent = `돌림판이 멈췄습니다! 선택된 항목은 ${selectedItem}입니다.`;
        document.body.appendChild(announcement);
        
        setTimeout(() => {
            document.body.removeChild(announcement);
        }, 1000);
    }, 100);
};

// 입력창 키 이벤트 처리
const handleKeyPress = (event) => {
    if (event.key === 'Enter') {
        addItem();
    }
};

// ===================================================================
// 🌐 접근성 개선 - 키보드 네비게이션 및 ARIA 지원
// ===================================================================

// 키보드 네비게이션 핸들러
const handleGlobalKeyDown = (event) => {
    // 입력 필드에 포커스가 있을 때는 기본 동작 유지
    if (event.target.tagName === 'INPUT') {
        return;
    }
    
    // Ctrl/Cmd + Enter: 돌림판 돌리기
    if ((event.ctrlKey || event.metaKey) && event.key === 'Enter') {
        event.preventDefault();
        if (!spinButton.disabled) {
            spin();
        }
        return;
    }
    
    // Space 또는 Enter: 포커스된 버튼 클릭
    if ((event.key === ' ' || event.key === 'Enter') && 
        event.target.tagName === 'BUTTON') {
        event.preventDefault();
        event.target.click();
        return;
    }
    
    // Escape: 모달 닫기 (만약 있다면)
    if (event.key === 'Escape') {
        const modal = document.querySelector('[style*="position: fixed"]');
        if (modal) {
            modal.remove();
        }
        return;
    }
};

// 버튼 포커스 가시성 개선
const enhanceButtonFocus = () => {
    const buttons = document.querySelectorAll('button');
    buttons.forEach(button => {
        button.addEventListener('focus', () => {
            button.style.outline = '2px solid #3b82f6';
            button.style.outlineOffset = '2px';
        });
        
        button.addEventListener('blur', () => {
            button.style.outline = '';
            button.style.outlineOffset = '';
        });
    });
};

// 돌림판 영역 키보드 접근성
const enhanceRouletteAccessibility = () => {
    canvas.setAttribute('tabindex', '0');
    canvas.setAttribute('role', 'img');
    canvas.setAttribute('aria-label', `돌림판 (${items.length}개 항목)`);
    
    canvas.addEventListener('keydown', (event) => {
        if ((event.key === 'Enter' || event.key === ' ') && !spinButton.disabled) {
            event.preventDefault();
            spin();
        }
    });
};

// 스크린 리더를 위한 상태 알림
const announceToScreenReader = (message) => {
    const announcement = document.createElement('div');
    announcement.className = 'sr-only';
    announcement.setAttribute('aria-live', 'polite');
    announcement.setAttribute('aria-atomic', 'true');
    announcement.textContent = message;
    
    document.body.appendChild(announcement);
    
    setTimeout(() => {
        if (announcement.parentElement) {
            document.body.removeChild(announcement);
        }
    }, 1000);
};

// ===================================================================
// 🔗 간편 링크 복사 기능
// ===================================================================

// 공유 버튼 요소 가져오기
const shareButton = document.getElementById('share-button');

// 공유 버튼 클릭 이벤트 (클립보드 복사)
shareButton.addEventListener('click', async () => {
    try {
        // 현재 페이지 URL 복사
        const currentUrl = window.location.href;
        
        if (navigator.clipboard) {
            // 모던 브라우저: Clipboard API 사용
            await navigator.clipboard.writeText(currentUrl);
            showCopySuccess();
            console.log('📋 클립보드 복사 성공:', currentUrl);
        } else {
            // 구형 브라우저: 수동 복사
            const textArea = document.createElement('textarea');
            textArea.value = currentUrl;
            textArea.style.position = 'fixed';
            textArea.style.opacity = '0';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            showCopySuccess();
            console.log('📋 수동 복사 성공:', currentUrl);
        }
    } catch (error) {
        console.warn('⚠️ 클립보드 복사 실패:', error);
        // 복사 실패 시 URL을 직접 보여주기
        alert(`링크 복사에 실패했습니다.\n아래 주소를 직접 복사해주세요:\n\n${window.location.href}`);
    }
});

// 복사 성공 알림 표시
const showCopySuccess = () => {
    // 시각적 피드백을 위해 버튼 색상 잠시 변경
    const originalClass = shareButton.className;
    shareButton.className = shareButton.className.replace('bg-blue-500', 'bg-green-500');
    shareButton.className = shareButton.className.replace('hover:bg-blue-600', 'hover:bg-green-600');
    
    // 버튼 텍스트 잠시 변경
    const buttonText = shareButton.querySelector('span:last-child');
    const originalText = buttonText.textContent;
    buttonText.textContent = '복사됨!';
    
    // 성공 메시지
    alert('🔗 링크가 복사되었습니다!\n메신저나 다른 앱에서 붙여넣기하여 공유해보세요.');
    
    // 1.5초 후 원래 상태로 복원
    setTimeout(() => {
        shareButton.className = originalClass;
        buttonText.textContent = originalText;
    }, 1500);
};

// ===================================================================
// ⚡ 성능 최적화 시스템
// ===================================================================

// Debounce 함수 (과도한 호출 방지)
const debounce = (func, wait) => {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
};

// Throttle 함수 (애니메이션 최적화)
const throttle = (func, limit) => {
    let lastFunc;
    let lastRan;
    return function(...args) {
        if (!lastRan) {
            func.apply(this, args);
            lastRan = Date.now();
        } else {
            clearTimeout(lastFunc);
            lastFunc = setTimeout(() => {
                if ((Date.now() - lastRan) >= limit) {
                    func.apply(this, args);
                    lastRan = Date.now();
                }
            }, limit - (Date.now() - lastRan));
        }
    };
};

// 메모리 사용량 모니터링
const monitorMemory = () => {
    if (performance.memory) {
        const memory = performance.memory;
        console.log(`📊 메모리 사용량: ${(memory.usedJSHeapSize / 1024 / 1024).toFixed(2)}MB / ${(memory.totalJSHeapSize / 1024 / 1024).toFixed(2)}MB`);
        
        // 메모리 사용량이 너무 높으면 경고
        if (memory.usedJSHeapSize / memory.totalJSHeapSize > 0.9) {
            console.warn('⚠️ 메모리 사용량이 높습니다. 가비지 컬렉션을 고려하세요.');
        }
    }
};

// DOM 업데이트 최적화를 위한 배치 처리
const batchDOMUpdates = (updates) => {
    requestAnimationFrame(() => {
        updates.forEach(update => update());
    });
};

// 이벤트 리스너 정리를 위한 WeakMap
const eventListeners = new WeakMap();

// 안전한 이벤트 리스너 추가
const addSafeEventListener = (element, event, handler, options = {}) => {
    try {
        element.addEventListener(event, handler, options);
        
        // 정리를 위해 저장
        if (!eventListeners.has(element)) {
            eventListeners.set(element, []);
        }
        eventListeners.get(element).push({ event, handler, options });
        
    } catch (error) {
        handleGlobalError(error, 'Event');
    }
};

// 이벤트 리스너 정리
const cleanupEventListeners = (element) => {
    const listeners = eventListeners.get(element);
    if (listeners) {
        listeners.forEach(({ event, handler, options }) => {
            try {
                element.removeEventListener(event, handler, options);
            } catch (error) {
                console.warn('이벤트 리스너 정리 실패:', error);
            }
        });
        eventListeners.delete(element);
    }
};

// ===================================================================
// 🛡️ 에러 처리 및 복구 시스템
// ===================================================================

// 전역 에러 핸들러
const handleGlobalError = (error, context = 'Unknown') => {
    console.error(`❌ [${context}] 오류 발생:`, error);
    
    // 사용자에게 친화적인 메시지 표시
    const errorMessages = {
        'Canvas': '돌림판 표시에 문제가 있습니다. 페이지를 새로고침해주세요.',
        'Storage': '저장 기능에 문제가 있습니다. 브라우저 설정을 확인해주세요.',
        'Animation': '애니메이션 재생에 문제가 있습니다.',
        'Input': '입력 처리에 문제가 있습니다.',
        'Network': '네트워크 연결을 확인해주세요.'
    };
    
    const message = errorMessages[context] || '예상치 못한 오류가 발생했습니다.';
    
    // 치명적이지 않은 오류는 콘솔에만 기록
    if (context === 'Animation' || context === 'Network') {
        return;
    }
    
    // 사용자에게 알림
    setTimeout(() => {
        alert(`⚠️ ${message}\n\n문제가 계속되면 페이지를 새로고침해주세요.`);
    }, 100);
};

// 캔버스 초기화 안전 검사
const safeInitializeCanvas = () => {
    try {
        if (!canvas || !ctx) {
            throw new Error('Canvas 또는 Context를 찾을 수 없습니다');
        }
        
        return initializeCanvas();
    } catch (error) {
        handleGlobalError(error, 'Canvas');
        
        // 기본값 반환
        return {
            centerX: 140,
            centerY: 140,
            radius: 120
        };
    }
};

// localStorage 안전 접근
const safeLocalStorage = {
    getItem: (key) => {
        try {
            return localStorage.getItem(key);
        } catch (error) {
            handleGlobalError(error, 'Storage');
            return null;
        }
    },
    
    setItem: (key, value) => {
        try {
            localStorage.setItem(key, value);
            return true;
        } catch (error) {
            handleGlobalError(error, 'Storage');
            return false;
        }
    },
    
    removeItem: (key) => {
        try {
            localStorage.removeItem(key);
            return true;
        } catch (error) {
            handleGlobalError(error, 'Storage');
            return false;
        }
    }
};

// 사용자 입력 검증 및 정제
const validateAndSanitizeInput = (input) => {
    if (typeof input !== 'string') {
        throw new Error('입력값이 문자열이 아닙니다');
    }
    
    // 공백 제거
    const trimmed = input.trim();
    
    // 길이 검증 (최대 50자)
    if (trimmed.length > 50) {
        throw new Error('항목 이름은 50자를 초과할 수 없습니다');
    }
    
    // 특수문자 제한 (기본적인 문자, 숫자, 한글, 공백만 허용)
    const allowedPattern = /^[a-zA-Z0-9가-힣ㄱ-ㅎㅏ-ㅣ\s\-_().]+$/;
    if (!allowedPattern.test(trimmed)) {
        throw new Error('허용되지 않는 문자가 포함되어 있습니다');
    }
    
    return trimmed;
};

// 애니메이션 안전 실행
const safeRequestAnimationFrame = (callback) => {
    try {
        return requestAnimationFrame(callback);
    } catch (error) {
        handleGlobalError(error, 'Animation');
        // 폴백: setTimeout 사용
        return setTimeout(callback, 16); // ~60fps
    }
};

// 캔버스 그리기 안전 실행
const safeDrawRoulette = () => {
    try {
        drawRoulette();
    } catch (error) {
        handleGlobalError(error, 'Canvas');
        
        // 캔버스 복구 시도
        try {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#f3f4f6';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#9ca3af';
            ctx.font = '16px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('돌림판 표시 오류', canvas.width / 2, canvas.height / 2);
        } catch (fallbackError) {
            console.error('캔버스 복구 실패:', fallbackError);
        }
    }
};

// ===================================================================
// [7. 이벤트 리스너 연결 및 초기화]
// ===================================================================
document.addEventListener('DOMContentLoaded', () => {
    // 🚀 카카오톡 인앱 브라우저 감지 및 처리 (최우선 실행)
    const isKakaoInApp = handleKakaoInAppBrowser();
    if (isKakaoInApp) {
        console.log('⚠️ 카카오톡 인앱 브라우저 환경 - 일부 기능 제한 가능');
    }
    
    // 캔버스 크기 초기화 (안전)
    canvasInfo = safeInitializeCanvas();
    
    // 전역 에러 핸들러 등록
    window.addEventListener('error', (event) => {
        handleGlobalError(event.error, 'Global');
    });
    
    window.addEventListener('unhandledrejection', (event) => {
        handleGlobalError(event.reason, 'Promise');
    });
    
    // '추가', '돌리기!', '리셋' 버튼에 각각의 함수를 정확히 연결
    addButton.addEventListener('click', addItem);
    spinButton.addEventListener('click', spin);
    resetButton.addEventListener('click', reset);
    itemInput.addEventListener('keypress', handleKeyPress);
    
    // 즐겨찾기 관련 이벤트 리스너 연결
    saveFavoriteButton.addEventListener('click', saveFavorite);
    clearAllFavoritesButton.addEventListener('click', clearAllFavorites);
    favoriteNameInput.addEventListener('input', updateSaveFavoriteButton);
    favoriteNameInput.addEventListener('keypress', (event) => {
        if (event.key === 'Enter') {
            saveFavorite();
        }
    });
    
    // 화면 회전 및 리사이즈 대응 (성능 최적화)
    const debouncedResize = debounce(() => {
        canvasInfo = safeInitializeCanvas();
        safeDrawRoulette();
    }, 150);
    
    window.addEventListener('resize', debouncedResize);
    
    // 화면 방향 변경 대응
    window.addEventListener('orientationchange', debouncedResize);
    
    // 초기 상태 설정
    currentRotation = 0;
    isSpinning = false;
    preSelectedWinner = null;
    
    // 초기 UI 업데이트
    safeDrawRoulette();
    updateItemsList();
    updateSpinButtonState();
    updateSaveFavoriteButton();
    updateFavoritesList();
    
    // 접근성 기능 활성화
    document.addEventListener('keydown', handleGlobalKeyDown);
    enhanceButtonFocus();
    enhanceRouletteAccessibility();
    
    // 초기 포커스 (모바일에서는 자동 포커스 방지)
    if (window.innerWidth > 768) {
        itemInput.focus();
    }
    
    // 성능 모니터링 시작
    monitorMemory();
    setInterval(monitorMemory, 30000); // 30초마다 메모리 체크
    
    console.log(`🎪 === 전문가급 PWA 돌림판 시스템 초기화 완료 ===`);
    console.log(`📱 완전 반응형 모바일 최적화 (vw/vh 기반)`);
    console.log(`🚀 카카오톡 인앱 브라우저 자동 전환 지원`);
    console.log(`📐 수학적으로 완벽한 계산식 적용`);
    console.log(`🎯 완전 분리된 로직 (drawRoulette + spin + reset)`);
    console.log(`✅ 100% 정확한 결과 보장`);
    console.log(`🔄 리셋 기능 추가`);
    console.log(`💾 즐겨찾기 저장/불러오기 기능 추가`);
    console.log(`🔗 간편 링크 복사 공유 기능`);
    console.log(`🎨 동적 뷰포트 크기 조정 시스템`);
    console.log(`🛡️ 강화된 보안 및 에러 처리`);
    console.log(`🌐 접근성 개선 (키보드 네비게이션, ARIA)`);
    console.log(`⚡ 성능 최적화 (debounce, throttle, 메모리 관리)`);
    console.log(`📏 캔버스 크기: ${canvasInfo.centerX * 2}x${canvasInfo.centerY * 2}px`);
    console.log(`🌐 화면 크기: ${window.innerWidth}x${window.innerHeight}px`);
    console.log(`═══════════════════════════════════\n`);
});

// 전역 함수로 노출 (HTML에서 호출용)
window.removeItem = removeItem; 

console.log('🔗 링크 복사 기능 활성화됨 - 모든 브라우저 지원');
    </script>
    
    <!-- PWA Service Worker 등록 -->
    <script>
        // Service Worker 등록
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then((registration) => {
                        console.log('Service Worker 등록 성공:', registration.scope);
                    })
                    .catch((error) => {
                        console.log('Service Worker 등록 실패:', error);
                    });
            });
        }

        // PWA 설치 배너
        let deferredPrompt;
        const installButton = document.createElement('button');
        installButton.textContent = '앱 설치';
        installButton.className = 'fixed bottom-4 right-4 bg-green-500 text-white px-4 py-2 rounded-lg shadow-lg hover:bg-green-600 transition-colors z-50';
        installButton.style.display = 'none';

        window.addEventListener('beforeinstallprompt', (e) => {
            console.log('PWA 설치 배너 준비됨');
            e.preventDefault();
            deferredPrompt = e;
            
            // 설치 버튼 표시
            document.body.appendChild(installButton);
            installButton.style.display = 'block';
        });

        installButton.addEventListener('click', async () => {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;
                console.log(`사용자 선택: ${outcome}`);
                
                if (outcome === 'accepted') {
                    console.log('PWA 설치됨');
                }
                
                deferredPrompt = null;
                installButton.style.display = 'none';
            }
        });

        // 앱이 설치된 후
        window.addEventListener('appinstalled', () => {
            console.log('PWA가 성공적으로 설치되었습니다!');
            installButton.style.display = 'none';
            deferredPrompt = null;
        });

        // PWA 실행 감지
        window.addEventListener('DOMContentLoaded', () => {
            if (window.matchMedia('(display-mode: standalone)').matches) {
                console.log('PWA 모드로 실행 중');
                // PWA 모드에서만 보이는 기능 추가 가능
            }
        });
    </script>
</body>
</html> 